<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>El Hekma | Smart Location Feedback (high-accuracy)</title>
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f6f8fa; margin:0; color:#222; }
    .container { max-width:520px; margin:40px auto; background:#fff; border-radius:14px; box-shadow:0 4px 24px #0001; padding:30px 22px; text-align:center;}
    h3 { color:#2267b7; margin:0 0 12px 0; font-size:1.2rem; }
    #status { margin:14px auto 18px; padding:12px 18px; background:#fff3cd; color:#856404; border-radius:7px; min-height:54px; transition:all .3s; }
    #status.error { background:#fdeaea; color:#c91e2c; }
    #status.success { background:#e8f5e9; color:#207d32; }
    #controls { margin-bottom:12px; display:none; }
    button { padding:9px 14px; border-radius:8px; border:0; background:#2267b7; color:#fff; cursor:pointer; }
    button:hover{ background:#195497; }
    .spinner { border:3px solid #eee; border-top:3px solid #2267b7; border-radius:50%; width:24px; height:24px; display:inline-block; animation:spin 1s linear infinite; vertical-align:middle; margin-right:8px; }
    @keyframes spin { to { transform:rotate(360deg); } }
    small { display:block; margin-top:8px; color:#666; }
    iframe { width:100%; height:600px; border:0; border-radius:8px; display:none; background:#f2f3f5; }
    @media(max-width:650px){ .container{ padding:12px 8px } iframe{ height:440px } }
  </style>
</head>
<body>
  <div class="container">
    <h3>Your location will be auto-filled in the form</h3>
    <div id="status"><span class="spinner"></span>Checking location permissionsâ€¦</div>

    <div id="controls">
      <button id="requestBtn">Allow Location</button>
      <button id="retryBtn" style="display:none">Retry</button>
    </div>

    <iframe id="myForm" allow="geolocation" title="Google Form">Loadingâ€¦</iframe>
  </div>

  <script>
  // ---------- CONFIG ----------
  const FORM_BASE_URL = "https://docs.google.com/forms/d/1PxC3Z-hrlVTmSoQzMZN3ZO1hVyJv6r7K5Le1GyVj1K0/viewform?usp=pp_url";
  const entryLocation = "entry.123519381";
  const CONTACT_EMAIL = "mmm842218@gmail.com";
  const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
  const WATCH_TIMEOUT = 8000; // wait up to 8 seconds to collect good reading
  const DESIRED_ACCURACY = 30; // meters (target accuracy)
  const GEOCODE_FAST_TIMEOUT = 3000; // ms for fast geocode race
  // ----------------------------

  const statusEl = document.getElementById("status");
  const controlsEl = document.getElementById("controls");
  const requestBtn = document.getElementById("requestBtn");
  const retryBtn = document.getElementById("retryBtn");
  const iframeEl = document.getElementById("myForm");

  function setStatus(html, cls = "") {
    statusEl.innerHTML = html;
    statusEl.className = cls;
  }

  function cleanAddress(s) {
    if (!s) return "";
    // remove Arabic text and unusual unicode, keep basic punctuation
    s = s.replace(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]+/g, "");
    s = s.replace(/\s{2,}/g, " ").trim();
    return s;
  }

  function isValidCoords(lat, lon) {
    return lat !== null && lon !== null && !isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0 &&
           Math.abs(lat) <= 90 && Math.abs(lon) <= 180;
  }

  function saveCache(lat, lon, address) {
    localStorage.setItem('locationCache', JSON.stringify({ lat, lon, address, ts: Date.now() }));
  }
  function loadCache() {
    try {
      const c = JSON.parse(localStorage.getItem('locationCache'));
      if (!c) return null;
      if (Date.now() - c.ts > CACHE_DURATION) return null;
      return c;
    } catch { return null; }
  }

  // dual geocode: BigDataCloud first (fast), fallback Nominatim
  async function reverseGeocode(lat, lon) {
    const fastUrl = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`;
    const slowUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&accept-language=en&email=${encodeURIComponent(CONTACT_EMAIL)}`;

    // try fast with timeout
    try {
      const fast = await Promise.race([
        fetch(fastUrl).then(r => r.ok ? r.json() : Promise.reject()),
        new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), GEOCODE_FAST_TIMEOUT))
      ]);
      if (fast && (fast.city || fast.locality || fast.principalSubdivision)) {
        const parts = `${fast.locality || fast.city || ''}, ${fast.principalSubdivision || ''}, ${fast.countryName || ''}`;
        return cleanAddress(parts);
      }
    } catch (e) {
      // ignore and fallback
      console.warn('BigDataCloud failed or timed out:', e && e.message);
    }

    // fallback
    try {
      const r = await fetch(slowUrl, { headers: { 'User-Agent': `ElHekma/geo (+${CONTACT_EMAIL})` }});
      if (r.ok) {
        const data = await r.json();
        return cleanAddress(data?.display_name || "");
      }
    } catch (e) {
      console.warn('Nominatim failed:', e && e.message);
    }
    return "";
  }

  function buildFormUrl(lat, lon, address) {
    const mapsLink = `https://www.google.com/maps?q=${lat},${lon}`;
    const value = `${address} | ${mapsLink}`;
    const unique = `nocache=${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
    return `${FORM_BASE_URL}&${entryLocation}=${encodeURIComponent(value)}&${unique}`;
  }

  // Best-effort watchPosition: collect readings, choose best (smallest accuracy)
  function getBestPosition(timeout = WATCH_TIMEOUT, targetAccuracy = DESIRED_ACCURACY) {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
      let best = null;
      let watchId = null;
      let finished = false;

      function finish(pos) {
        if (finished) return;
        finished = true;
        if (watchId !== null) navigator.geolocation.clearWatch(watchId);
        resolve(best || pos);
      }

      function onSuccess(pos) {
        const c = pos.coords;
        // ignore invalid
        if (!isValidCoords(c.latitude, c.longitude)) return;
        // store best by accuracy
        if (!best || (c.accuracy && c.accuracy < (best.coords.accuracy || Infinity))) {
          best = pos;
        }
        // if accuracy good enough, finish early
        if (c.accuracy && c.accuracy <= targetAccuracy) {
          finish(pos);
        }
        // otherwise keep watching until timeout
      }

      function onError(err) {
        // if we already have a best reading, resolve it, else reject
        console.warn('watchPosition error', err);
        if (best) finish(best);
        else reject(err);
      }

      // start watch
      try {
        watchId = navigator.geolocation.watchPosition(onSuccess, onError, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: timeout
        });
      } catch (e) {
        return reject(e);
      }

      // enforce timeout: after timeout ms, resolve best if exists or reject
      const to = setTimeout(() => {
        if (best) finish(best);
        else {
          if (watchId !== null) navigator.geolocation.clearWatch(watchId);
          finished = true;
          reject(new Error('Timeout waiting for position'));
        }
      }, timeout + 300); // small buffer
    });
  }

  async function setLocationFlow(force = false) {
    setStatus('<span class="spinner"></span> Getting your locationâ€¦', 'loading');
    controlsEl.style.display = 'none';

    // use cache if available and not forced
    const cache = !force ? loadCache() : null;
    if (cache) {
      setStatus('ðŸ“ Using cached location (updates in background)â€¦', 'success');
      iframeEl.src = buildFormUrl(cache.lat, cache.lon, cache.address);
      iframeEl.style.display = 'block';
      // background update (do not block)
      try {
        const pos = await getBestPosition(4000, DESIRED_ACCURACY);
        // if significantly different, update
        const lat = pos.coords.latitude, lon = pos.coords.longitude;
        if (Math.abs(lat - cache.lat) > 0.0005 || Math.abs(lon - cache.lon) > 0.0005) {
          const address = await reverseGeocodeAndSave(lat, lon);
          if (address) {
            iframeEl.src = buildFormUrl(lat, lon, address);
          }
        }
      } catch (e) { /* ignore background failures */ }
      return;
    }

    // get best reading using watchPosition
    try {
      const pos = await getBestPosition(); // waits up to WATCH_TIMEOUT
      const lat = pos.coords.latitude, lon = pos.coords.longitude, accuracy = pos.coords.accuracy;
      setStatus(`ðŸ“ Coordinates obtained (accuracy ~ ${accuracy ? Math.round(accuracy) + ' m' : 'n/a'}) â€” resolving address...`, 'loading');
      const address = await reverseGeocodeAndSave(lat, lon);
      if (address) {
        iframeEl.src = buildFormUrl(lat, lon, address);
        iframeEl.style.display = 'block';
        setStatus('âœ… Location detected successfully!', 'success');
      } else {
        setStatus('âš ï¸ Could not obtain a valid English address. Please retry.', 'error');
        controlsEl.style.display = 'block';
      }
    } catch (err) {
      console.warn('Could not get high-accuracy position:', err && err.message);
      // fallback to single getCurrentPosition (less accurate) before giving up
      setStatus('âš ï¸ High-accuracy read failed, trying quick fallback...', 'loading');
      navigator.geolocation.getCurrentPosition(async pos => {
        const lat = pos.coords.latitude, lon = pos.coords.longitude;
        if (!isValidCoords(lat, lon)) {
          setStatus('âŒ Invalid coordinates. Please enable location and retry.', 'error');
          controlsEl.style.display = 'block';
          return;
        }
        const address = await reverseGeocodeAndSave(lat, lon);
        if (address) {
          iframeEl.src = buildFormUrl(lat, lon, address);
          iframeEl.style.display = 'block';
          setStatus('âœ… Location detected (fallback).', 'success');
        } else {
          setStatus('âš ï¸ Unable to retrieve address. Retry later.', 'error');
          controlsEl.style.display = 'block';
        }
      }, (e) => {
        setStatus('âŒ Please enable location access and reload.', 'error');
        controlsEl.style.display = 'block';
      }, { enableHighAccuracy:true, timeout:10000 });
    }
  }

  async function reverseGeocodeAndSave(lat, lon) {
    const address = await reverseGeocode(lat, lon);
    if (address && address.length > 0) {
      saveCache(lat, lon, address);
      return address;
    }
    return "";
  }

  function init() {
    if (!window.isSecureContext && !location.hostname.includes('localhost')) {
      setStatus('âš ï¸ Page must be loaded via HTTPS for location to work.', 'error');
      return;
    }
    if (!navigator.geolocation) {
      setStatus('âŒ Geolocation not supported in this browser.', 'error');
      return;
    }

    // permission check and UI
    if (navigator.permissions && navigator.permissions.query) {
      navigator.permissions.query({ name: 'geolocation' }).then(res => {
        if (res.state === 'granted') {
          setLocationFlow();
        } else {
          setStatus('ðŸ“ Please allow location access and click "Allow Location".', 'error');
          controlsEl.style.display = 'block';
        }
        res.onchange = () => init();
      }).catch(() => { controlsEl.style.display = 'block'; });
    } else {
      controlsEl.style.display = 'block';
    }
  }

  requestBtn.addEventListener('click', () => setLocationFlow(true));
  retryBtn.addEventListener('click', () => setLocationFlow(true));
  document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
